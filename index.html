<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/white.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/a11y-light.css">


  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);

  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!-- Heading section -->
      <section data-markdown>
        <textarea data-template>
            # Recursion schemes
            <p>A simple take, a mix of intuitions</p>
	      </textarea>
      </section>

      <!-- Slide 2 -->
      <section data-transition="fade-in">
        <h3>Why ? </h3>
        <ul style="font-size:35px">
          <li>Push yourself a bit more, you get comfortable with where you begun</li>
          <li>We learned abstractions</li>
          <li>We learned recursions</li>
          <li>We push a bit more to learn to "abstract" "recursions"</li>
          <li>Finally, be comfortable with both abstractions and recursions</li>
        </ul>
      </section>


      <!-- Slide 3 -->

      <section data-transition="fade-in">
        <h3>Recursion Examples</h3>
        <ul>
          <li>To sum a list</li>
          <li>Retry computations</li>
          <li>optimise a pogram</li>
          <li>typelevel recursion</li>
          <li>and what not!</li>
        </ul>
      </section>

            <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Sum recursively</h3>
        <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape> 
	  sum :: List Int -> Int
	  sum Nil = 0
	  sum h :. t = h + (sum tail) 
       </code></pre>
      </section>
 
      <!-- Slide 18 -->

      <section data-transition="fade-out">
        <h3>Type match [scala3] (recursively)</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim data-trim data-line-numbers="1-10">
          type TupleMap[T <: Tuple, F[_]] <: Tuple = T match {
            case EmptyTuple => EmptyTuple
            case h *: t => F[h] *: TupleMap[t, F]
          }
        </code></pre>
      </section>


      <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Type match [scala3] (recursively)</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim>
          type ISD = (Int, Double, Long)
          val result: TupleMap[ISD, Option] = (Some(1), Some("2"), Some("3"))
          // Same as val result: (Option[Int], Option[Double], Option[String]
        </code></pre>
      </section>

      <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Type match [scala3] (recursively)</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim>
          val result: ??? = 
            sequence((Some(1), Some("2"), Some("3")))
          
          def sequence[T <: Tuple](t: T): ??? = ???
        </code></pre>
      </section>

      <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Type match [scala3] (recursively)</h3>
        <pre><code class="hljs scala" style="font-size:22px;" data-trim>
          type TupleInverseMap[T, F[_]] <: Tuple = T match {
            case EmptyTuple => EmptyTuple
            case F[h] *: t => h *: TupleInverseMap[t, F]
          }        
        </code></pre>
      </section>      

      <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Type match [scala3] (recursively)</h3>
        <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>  
          def unsafeSequence[T <: Tuple](
            x: T
          ): Option[TupleInverseMap[T, Option]] = ???
       </code></pre>
      </section>


      <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Type match [scala3] (recursively)</h3>
        <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>        
          def sequence[T <: Tuple](
            x: TupleMap[T, Option]
          ): Option[TupleInverseMap[T, Option]] = ???
          // internally uses traverse(identity) using typelevel recursions  
       </code></pre>
      </section>

      <!-- Slide -->
      <section data-transition="fade-out">
        <h3>Define typelevel Bound using recursion</h3>
        <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
          import scala.compiletime.S

          val one: S[0] = 1
       </code></pre>
      </section>      

        <!-- Slide -->
        <section data-transition="fade-out">
          <h3>Define typelevel Bound using recursion</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            Given compiletime.S, and singleton type,
            Define a type `Bound[Min, Max]` such that 
            val x: Bound[1, 10] = 11 
            fails to compile
         </code></pre>
        </section>    

        <!-- Slide -->
        <section data-transition="fade-out">
          <h3>Define typelevel Bound using recursion</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            type Bound[Min <: Int, Max <: Int] <: Int = Max match {
              case Min => Min
              case S[m] => Max | Bound[Min, m]
            }
         </code></pre>
        </section> 

               <!-- Slide -->
        <section data-transition="fade-out">
          <h3>Define typelevel Bound using recursion</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
             val x: Bound[1, 10] = 11 // is compile time error
         </code></pre>
        </section> 
        
        <!-- Slide -->
        <section data-transition="fade-out">
          <h3>Exponential Back off Retries</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>
         
def getUser(userId: Int): User = ???

def getUserWithRetry(initialDelay: FiniteDuration, max: Int): User
  if(max <= 1) 
    getUser(1)
  else 
   try {
    getUser(1)
   } catch (Exception e) {
      retry(initialDelay * 2, max - 1)  
   }
      </code></pre>
        </section> 
          
           

	<!-- Slide -->

          <!-- Slide -->
          <section data-transition="fade-out">
            <h3>Exponential Back off Retries</h3>
            <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>
           
  def getUser(userId: Int): User = ???
  
  def retry(getUser: => User, initialDelay: FiniteDuration, max: Int): User
    if(max <= 1) 
      getUser(1)
    else 
      try {
        getUser(1)
      } catch (Exception e) {
          retry(getUser, initialDelay * 2, max - 1)  
      }

  retry(getUser(1), 20.seconds, 5)     
        </code></pre>
          </section> 


                    <!-- Slide -->
          <section data-transition="fade-out">
            <h3>Exponential Back off Retries</h3>
            <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>
           
  def getUser(userId: Int): User = ???
  
  def retry[A](pgm: => A, initialDelay: FiniteDuration, max: Int): A
    if(max <= 1) 
      pgm
    else 
      try {
        pgm
      } catch (Exception e) {
          retry(pgm, initialDelay * 2, max - 1)  
      }

  retry(getUser(1), 20.seconds, 5)     
        </code></pre>
          </section> 


                              <!-- Slide -->
          <section data-transition="fade-out">
            <h3>Exponential Back off Retries</h3>
            <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>
           
  def getUser(userId: Int): IO[User] = ???
  
  def retry[A](pgm: IO[A], initialDelay: FiniteDuration, max: Int): IO[A]
    if(max <= 1) 
      pgm
    else 
      pgm.attempt.flatMap {
       case Left(_) => retry(pgm, initialDelay, max - 1)
       case Right(a) => IO.pure(a)
     }
     
  retry(getUser(1), 20.seconds, 5)     
        </code></pre>
          </section> 
            

                                        <!-- Slide -->
          <section data-transition="fade-out">
            <h3>Exponential Back off Retries</h3>
            <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>
           
  def getUser(userId: Int): IO[User] = ???
  
  def retry[A](pgm: IO[A], initialDelay: FiniteDuration, max: Int): IO[A]
    if(max <= 1) 
      pgm
    else 
      pgm.attempt.flatMap {
       case Left(_) => retry(pgm, intitialDelay, max - 1)
       case Right(a) => IO.pure(a)
     }
     
  retry(getUser(1), 20.seconds, 5)
    .onError( _ => notifyCustomer("Caution!"))   
        </code></pre>
          </section> 

                                        <!-- Slide -->
          <section data-transition="fade-out">
            <h3>Takes a program, and returns another program</h3>
            <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>
          
            def resilientPgm(nonResilientPgm: IO[A]): IO[A] = ??? 
            // returns a description that represents some recursion now  

        </code></pre>
          </section>


                                        <!-- Slide -->
          <section data-transition="fade-out">
            <h3>Takes a program, and returns another program</h3>
            <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>
          
            def optimiseProgram(nonOptimisedPgm: IO[A]): IO[A] = ??? 
            // returns a description that optimises the program
        </code></pre>
          </section> 


                                               <!-- Slide -->
          <section data-transition="fade-out">
            <h3>Optimise program</h3>
            <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>
          
            def optimiseProgram(program: Dataset[A]): Dataset[A] = ???
            // returns a description that optimises the program, possibly using recursion

            Caution: Spark DataSet are not values, they do lot of talking in between.
        </code></pre>
          </section> 
            

                                               <!-- Slide -->
          <section data-transition="fade-out">
            <h3>Manipulate Program</h3>
            <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim data-noescape>
          
              // A program
              sealed trait Expr

              case class IntValue(v: Int)           extends Expr
              case class DecValue(v: Double)        extends Expr
              case class Sum(a: Expr, b: Expr)      extends Expr
              case class Multiply(a: Expr, b: Expr) extends Expr
              case class Square(a: Expr)            extends Expr
              case class Divide(a: Expr, b: Expr)   extends Expr

              val expr = Divide(DecValue(5.2), Multiply(IntValue(10), IntValue(10)))
              
        </code></pre>
          </section> 
            
             
  
    <!-- Slide -->

        <section data-transition="fade-out">
          <h3>Walk through the program</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            def mulToSquare(expr: Expr): Expr = 
             expr match {
               case Sum(e1, e2)       => Sum(mulToSquare(e1), mulToSquare(e2))
               case Multiply(e3, e4)  => 
                 val r1 = mulToSquare(e3)
                 val r2 = mulToSquare(e4)
                 if (r1 == r2) Square(r1) else Multiply(r1, r2)
               case Square(a)         => Square(mulToSquare(a))
               case Divide(a, b)      => Divide(mulToSquare(a), mulToSquare(b))
               case a                 => a // just to fit slide   
             }

             mulToSquare(expr) ===> Divide(DecValue(5.2), Square(IntValue(10)))
         </code></pre>
        </section>

                <!-- Slide -->

        <section data-transition="fade-out">
          <h3>Zio-config</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            sealed trait Config[A]

            case class Source[A](source: Source) extends ConfigDescriptor[A]
            case class Default[A](config: Config[A], default: A) extends Config[A]
            case class Describe[A](config: Config[A], message: String) extends Config[A]
            case Optional[A](config: Config[A]) extends Config[Option[A]]
            case class OrElse[A](left: Config[A], right: Config[A]) extends Config[A]
            case class Sequence[A](config: Config[A]) extends Config[List[A]]
            // More nodes

         </code></pre>
        </section>

       <!-- Slide -->

        <section data-transition="fade-out">
          <h3>Zio-config</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            val pgm = 
             map(int.orElseEither(string))
               .xmap {
                  case Some((k, v)) => 
                    v match {
                      case Right(string) if string == "latest" => Right(VersionInfo(k, Latest)) 
                      case Left(n) => Right(VersionInfo(k, Number(n)))
                      case _ => ..
                    }
               }

         </code></pre>
        </section>


        <section data-transition="fade-out">
          <h3>Zio-config</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            generateSampleConfig(pgm, 1)

            "version-info" : {
              "QK8mNc5eciBlH" : "latest"
             }

         </code></pre>
        </section>

        <section data-transition="fade-out">
          <h3>Zio-config</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            generateSampleConfig(pgm, 1)
            // is
            def write[A](pgm: Config[A], value: A): Tree[A] = 
              pgm match {
                case OrElse(left, right) => 
                  write(left, value) andThen write(right, value)
                case Sequence(list) => list.map(write).sequence.........  
              }

         </code></pre>
        </section>

        <section data-transition="fade-out">
          <h3>Zio-config</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
        
            // Massive recursions, that became extremely complicated in 
            // a period of 2-3 months.
            def write(config: Config[A], value: A): Tree[A] = ???
            def toJson(tree: Tree[A]): Json = ???
            def toMap(tree: Tree[A]): Map[String, String] = ???
            def document(pgm: Config[A]): ConfigDocs[A] = ???
            def jsonDocument(configDocs: ConfigDocs[A]): Json = ???


            // It's complex enough, and yes, I miss a recursion scheme library until I started
            // writing something exciting.
         </code></pre>
        </section>
        


        <section data-transition="fade-out">
          <h3>Zio-config</h3>
          The recursions are verbose and I truly miss a recursion scheme library.
          Something that I could never return to.
        </section>

        <section data-transition="fade-out">
          <h3>Complex recursions (should/could) be factored out</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            // Scio, Beam, Flink, Spark and many more
            def interpret(dsl: Dsl[A]): IO[spark.DataFrame[A]]
            def interpret(dsl: Dsl[A]): IO[flink.DataSet[A]]
         </code></pre>
        </section> 
        

        <section data-transition="fade-out">
          <h3>Try not to delay abstractions</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            
            Let's keep it simple <=> 
            Let's (fail to) deal with complexity in future

         </code></pre>
        </section>

        <section data-transition="fade-out">
          <h3>So let's abstract recursions</h3>
        </section>     

        <section data-transition="fade-out">
          <h3>The very famous example, but we are pushing more here</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            def factorial(n: Int): Int = 
              if (n == 0) 1 else n * factorial (n - 1)
         </code></pre>
        </section>

        <section data-transition="fade-out">
          <h3>The very famous example, but we are pushing more here</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            def almostFactorial(f: Int => Int): Int => Int = 
              if (n == 0) 1 else n * f (n - 1)
         </code></pre>
        </section>

        <section data-transition="fade-out">
          <h3>Time to fix points</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            def almostFactorial(f: Int => Int): Int => Int = 
              n => if (n == 0) 1 else n * f (n - 1)

            // pseudo code
            def factorial = almostFatorial(almostFactorial(almostFactorial))...
            
            // pseudo code
            // almostFactorial :: (Int -> Int) -> (Int -> Int)
            def factorial = almostFactorial factorial

            // factorial is a fix point of almostFactorial
            def fix(f: (Int => Int) => (Int => Int)): Int => Int = f(fix(f))

            // Not pseudo code, it really works
            def factorial = fix(almostFactorial)

         </code></pre>
        </section>

        <section data-transition="fade-out">
          <h3>Time to fix points</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
           // Here is the technique
           def factorial = fix(almostFactorial) // stack overflow

           // Given,
           f :: Int -> Int
          
           g = f 
           // is also
           g = \n -> f(n)

           def fix(f: (Int => Int) => (Int => Int)): Int => Int = 
             fix (a => f(fix(f))(a))

           def factorial = fix(almostFactorial) // works, no stack issues.  

         </code></pre>
        </section>

        <section data-transition="fade-out">
          <h3>Time to fix points</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            
            // You cannot replace the occurance of fix with its body
            // coz it consist of free variables.
            val fix = 
             (f: (Int => Int) => (Int => Int)) => fix (a => f(fix(f))(a))

           // So, challenge is can you try to make it non recursive in nature?
           // Consider it as a challenge/fun.

          </code></pre>
        </section>

        <section data-transition="fade-out">
          <h3>Push a bit more</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
            
 // Hardly found a scala proof for y-combinator: Head on to
 // https://afsalthaj.github.io/myblog/posts/2021-04-15-fix-points.html

 // A scala2 (dirty) version of https://mvanier.livejournal.com/2897.html          
 def y[A, B] = 
 (f: (A => B) => (A => B)) => {
   val lambdaXFxx = 
     ((x: Any) => f((y: A) => x.asInstanceOf[Any => (A => B)](x)(y)))
   f(lambdaXFxx(lambdaXFxx))
 }

 def factorial: Int => Int = y(almostFactorial)

          </code></pre>
        </section>

        <section data-transition="fade-out">
          <h3>Push a bit more towards Scala3</h3>
          <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim data-noescape>
// Caution: It's relatively non-intuitive to implement
// And deviates a bit from https://mvanier.livejournal.com/2897.html
def y[A, B] = 
  (f: (A => B) => (A => B)) => {
    lazy val lambda:[Z] => Z => (A => B) = 
      ([Z] => (z: Z) => f((y: A) => lambda(z)(y)))
    f(lambda(lambda))
  }

def factorial: Int => Int = y(almostFactorial)

          </code></pre>
        </section>



        <section data-transition="fade-out">
          <h3>Sorry for that intentional diversion</h3>
          <h3>But yes, limitless possibilites</h3>
        </section>
                <!-- Slide -->

                <section data-transition="fade-out">
                  <h3>Let's get back to something more simpler</h3>
                  <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                    s3://bucket/prefix/partition=2011-09-08/version=1/run_time=22222
                    s3://bucket/prefix/version=1/partition=2011-09-08/run_time=22222
                    // Can you spot a non-quite-obvious difference?

                 </code></pre>
                </section>

                <section data-transition="fade-out">
                  <h3>Here is a simple, yet, fragile example</h3>
                  <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                    s3://bucket/prefix/partition=2011-09-08/version=1/run_time=22222
                    s3://bucket/prefix/version=1/partition=2011-09-08/run_time=22222
                    s3://bucket/prefix/partition=2011-09-08/run_time=22222
                    // Can you spot a non-quite-obvious difference?

                 </code></pre>
                </section>

                <section data-transition="fade-out">
                  <h3>Here is a simple, yet, fragile example</h3>
                  <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                    s3://bucket/prefix/partition=2011-09-08/version=1/run_time=22222
                    s3://bucket/prefix/version=1/partition=2011-09-08/run_time=22222
                    s3://bucket/prefix/version=1/partition=2011-09-08/relationship_id=10/run_time=22222
                    // Can you spot a non-quite-obvious difference?
                 </code></pre>
                </section>
              
                <section data-transition="fade-out">
                  <h3>Here is a simple, yet, fragile example</h3>
                  <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                    sealed trait Component

                    object Components {
                      case class Version(n: String, v: Int) extends Component
                      case class AdhocPartition(n: String, v: String) extends Component 
                      case class RunTime(n: String, v: Long) extends Component
                      case class Partition(n: String, d: LocalDateTime) extends Component
                    }

                    final case class Path(current: Component, next: Option[Path])

                    //PS: Yes, Component is same as case class KeyValue(name: String, type: Component)
                  
                 </code></pre>
                </section>

                <section data-transition="fade-out">
                  <h3>Well, a naive show (toString)</h3>
                  <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                    final case class Path(current: Component, next: Option[Path]) {
                      def show: current match {
                        case PartitionInfo(name, value)      => show(n, v.show, next)
                        case VersionInfo(name, value)        => show(n, v, next)
                        case AdhocPartitionInfo(name, value) => show(n, v, next)
                        case RunTimeInfo(n, v)               => show(n, v, next)
                      }

                      def show(n: String, v: String, tail: Option[Path]) = 
                        ss"${n}=${v}/${tail.map(_.asString).foldMap(identity)}".string
                    }
                 </code></pre>
                </section>
                
                <section data-transition="fade-out">
                  <h3>Beautiful Parser</h3>
                  <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                      val allParsers: List[Parser[Component]] =
                        List(getParser(partitionName)), 
                          getParser(versionName), getVersion(parseRunTime) ++ 
                          subPartitionNames.map(getParser)
                        )    
                 </code></pre>
                </section>
                
              <section data-transition="fade-out">
                <h3>Beautiful Parser</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                  import atto._, Atto._

                  lazy val parser: Parser[Path] =
                    for {
                      current <- allParsers.combineAll
                      _       <- string("/")
                      next    <- opt(parser)
                  } yield SubPath(current, next)
               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>You can imagine having to loop this everytime</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                  // But its such a naive simple structure, 
                  // do you really need to abstract any more?
                  // Isn't it done? Yes, for the most part 
               </code></pre>
              </section>
                
              <section data-transition="fade-out">
                <h3>Ok, find out if s3 paths are having homogenous structure ?</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                  Defintion of homogenous here:
                  1. Position of a type and its name should be same across all paths
                  
                  2. Did it ever become heterogenous? 
                  Yes, a table/data became versionised after 2019.

                  3. Is it a bug in the source? 
                  No, we are running this for years. So we expect it.
               </code></pre>
              </section>  

              <section data-transition="fade-out">
                <h3>Process the latest directory</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                  If partition exists first, pick the latest version (if it exists) under the latest partition.
                  If runtime exists, pick the latest run_time under a latest version.
                  Or version exists first, pick the latest partition (if it exists) under the latest version.
                  If runtime exists, pick the latest run_time under a latest partition.
                  Permute of all of the above.
                  // Side note (unrelated): Do it with streaming, without taking all of the paths into memory.
               </code></pre>
              </section>

          
              <section data-transition="fade-out">
                <h3>Sure, what's the intuition?</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;" data-trim>
                  Here is the question.
                  Keep track of the position of these components, but don't pollute your business domain.
                  Challenge is to keep number of products and co-products as much less as possible.
               </code></pre>
              </section>
              
              <section data-transition="fade-out">
                <h3>Lets free ourselves</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  case class Path(current: Component, next: Option[Path])

                  val path = 
                    Path(Component.Version("minor_version", 10), Some(Path(Component.RunTime("run_time", 11), None)))


               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Lets free ourselves</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  case class Path(current: Component, next: Option[Path])

                 

               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Lets free ourselves</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  case class PathA(current: Component, next: Option[A])

                 

               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Lets free ourselves</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  type Path = PathA[Path] // Doesn't compile in Scala

                 

               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Lets free ourselves</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  case class Path(value: PathA[Path]) // Compiles in Scala

                 

               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Lets free ourselves</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  case class PathF[F[_]](value: F[PathF]) // Doesn't Compiles in Scala

                 

               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Lets free ourselves</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  case class PathF[F[_]](value: F[PathF[F]]) // Ok, compiles

                 

               </code></pre>
              </section>


              <section data-transition="fade-out">
                <h3>Lets free ourselves</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  case class Fix[F[_]](value: F[Fix[F]]) // remember fix(f) = f(fix(f)) ?

                 

               </code></pre>
              </section>


              <section data-transition="fade-out">
                <h3>Lets free ourselves</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  case class Fix[F[_]](unfix: F[Fix[F]]) // coz everyone says so

                 

               </code></pre>
              </section>


              <section data-transition="fade-out">
                <h3>Sure, but where is our Path?</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  case class Fix[F[_]](unfix: F[Fix[F]])
                  type Path = Fix[PathA] // case class PathA[A](current: Component, next: Option[A])
                 

               </code></pre>
              </section>
              
              
              <section data-transition="fade-out">
                <h3>Sure, but what's the point?</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  // To label positions of each path, just add Loc to Fix
           
                  type Loc = Int  // For demo, use newtypes

                  // It's something else - not Fix. Anyone?
                  case class Fix[F[_]](loc: Loc, unfix: F[Fix[F]])

           

               </code></pre>
              </section>

                     
              <section data-transition="fade-out">
                <h3>What's the point?.. Almost there..</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 
                  // To label positions of each path, just Cofree it
           
                  type Loc = Int  // For demo, use newtypes

                  // It's something else - not Fix. Anyone?
                  case class Cofree[F[_], A](a: A, value: F[Cofree[F]])

           

               </code></pre>
              </section>
         
              <section data-transition="fade-out">
                <h3>Get (Fix/Co) Free, avoid more data (&) manipulations</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                 // Our path exists non recursively forever
                 case class PathA[A](current: Component, next: Option[A])
                 
                 // Our recursive path is, always
                 type Path = Fix[PathA]

                 // Our recursive path with location is always
                 type PathLoc = Cofree[PathA, Loc]

                 // These three heavy lifting structures avoids duplications and manipulations
                 // that can be hurfully buggy.
           
               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Does this complicate my parser?</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
                def parser: Parser[Cofree[PathA, Int]] =
                  for {
                    loc     <- pos
                    current <- allParsers.combineAll // Monoid of parser is `orElse`
                    _       <- string("/")
                    next    <- opt(parser)
                  } yield Cofree(loc, cats.Eval.now(PathA(current, next)))

               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Sure, and then?</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
    
                 // Intuition is, you have many operations in Cofree (and even Fix), 
                 // that just simplifies 
                 // everything that you do with 
                 // otherwise logically recursive path with (almost) zero recursion logic.
                 
               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Headsup: Code heavy slides</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
    
                 // We can apply morphisms over Fix and Cofree.

                 // Code in upcoming slides is here.
                 https://gist.github.com/afsalthaj/809650b4c6e895084110269a3ecb8702

                 
               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>So, are two paths of same structure?</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
                 type Structure = List[(Int, String)]
                 val inclusion: Eval ~> cats.Id = _.value
                 val res = parser("minor_version=3/run_time=1/abc.txt")
                 def combine(a: (Int, String), b: Option[Structure]): Structure = ???
              
                 // path.next is Structure, and not child path.
                  Cofree.cataM(res)(
                    (pos, path) =>
                      path.current match {
                        case Version(name, _) => combine((pos, name), path.next) 
                        case RunTime(name, _) => combine((pos, name), path.next)
                      }
                  )(inclusion) 
               </code></pre>
              </section>


              <section data-transition="fade-out">
                <h3>Show path (See the pattern)</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
                 def combine[V](a: (V, Name), b: Option[String]): String = ???
              
                 //  sounds silly, yet important - and its just same impl
                 Cofree.cataM[PathA, Id, Int, String](parsed)(
                  (_, fb) =>
                    fb.current match {
                      case Version(n, v) => combine((v, n), fb.next)
                      case RunTime(n, v) => combine((v, n), fb.next)
                      case Adhoc(n, v)   => combine((v, n), fb.next)
                    }
                )(inclusion)
               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>(Details)For the above logic to work</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
    
                // PathA should have a Traverse instance, and this is fairly straight forward
                implicit val traversePathA: Traverse[PathA] = new Traverse[PathA] {
                  def traverse[G[_]: Applicative, A, B](fa: PathA[A])(f: A => G[B]): G[PathA[B]] = {
                    fa.next.map(f).fold(PathA(fa.current, None).pure[G]){ value =>
                      Applicative[G].map(value)(a => PathA(fa.current, Some(a)))
                    }
                  }
                }

               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Let's solve one more example.</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
    
                // Our original example of Multiply to Square
// Matryoshka: https://github.com/softwaremill/recursion-training#transforming-recursive-expressions
def mapNode(t: Fix[Expr])(f: Fix[Expr] => Fix[Expr])

def optimize(expr: Fix[Expr]): Fix[Expr] = expr.project match {
    case Multiply(a, b) if (a == b) => Square(a)
    case other => other
}

val optimizedExpr = mapNode(exprTree)(optimize)

                 
               </code></pre>
              </section>

              <section data-transition="fade-out">
                <h3>Effect on business logic: Before</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

                def mulToSquare(expr: Expr): Expr = 
                  expr match {
                    case Sum(e1, e2)       => Sum(mulToSquare(e1), mulToSquare(e2))
                    case Multiply(e3, e4)  => 
                      val r1 = mulToSquare(e3)
                      val r2 = mulToSquare(e4)
                      if (r1 == r2) Square(r1) else Multiply(r1, r2)
                    case Square(a)         => Square(mulToSquare(a))
                    case Divide(a, b)      => Divide(mulToSquare(a), mulToSquare(b))
                    case a                 => a // just to fit slide   
                  }
     
                  mulToSquare(expr) ===> Divide(DecValue(5.2), Square(IntValue(10)))

                 
               </code></pre>
              </section>


              <section data-transition="fade-out">
                <h3>Effect on business logic: After</h3>
                <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>

def mulToSquare(expr: Fix[Expr]): Fix[Expr] = expr.project match {
  case Multiply(a, b) if (a == b) => Square(a)
  case other => other
}

                 
               </code></pre>
              </section>

            </section>


            <section data-transition="fade-out">
              <h3>Map it to your recursive database table</h3>
              <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
                // The database id, should that be in your model?
                // A copy of Rob's (doobie author) talk
                case class ProfF[A](name: String, age: Int, student: List[A])
                type Prof = Fix[ProfF]
                type ProfId = Cofree[Prof, Int]
                      
             </code></pre>
            </section>

            <section data-transition="fade-out">
              <h3>Map it to your recursive database table</h3>
              <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
// insert children first 
def insert(op: Option[Int], p: ProfF[_]): ConnectionIO[Int] =
  tsql"""
    INSERT INTO prof (parent, name, year)
    VALUES ($op, ${p.name}, ${p.year})
    RETURNING id
  """.unique[Int]
                      
             </code></pre>
            </section>

            <section data-transition="fade-out">
              <h3>Map it to your recursive database table </h3>
              <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
              def insertTree(fp: Fix[ProfF], op: Option[Int]): ConnectionIO[Cofree[ProfF, Int]] =
                for {
                  h <- insertNode(op, fp.unfix)           // ConnectionIO[Int]
                  t <- fp.unfix                           // ProfF[Fix[ProfF]]
                         .travere(insertTree(_, Some(h))) // ConnectionIO[ProfF[Cofree[ProfF, Int]]]
                } yield Cofree(h, t)
                      
             </code></pre>
            </section>


            <section data-transition="fade-out">
              <h3>Read it back </h3>
              <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
            def readNode(id: Int): ConnectionIO[ProfF[Int]] =
              for {
                d  <- tsql"SELECT name, year FROM prof WHERE id = $id".unique[(String, Int)]
                ss <- tsql"SELECT id FROM prof WHERE parent = $id".as[List[Int]]
              } yield ProfF(d._1, d._2, ss)
                      
             </code></pre>
            </section>


            <section data-transition="fade-out">
              <h3>Read it back </h3>
              <p>Doing recursion at sql level is a choice for performance</p>
              <p>But not all usecases need to take that risk</p>
              <p>A recursion can be complex</p>
              <p>Should be backed by compile time safety</p>
              <p>Remove it from unsafe place, if performance concern is a lie</p>
            </section>


            <section data-transition="fade-out">
              <h3>Read it back </h3>
              <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
           def readNode(id: Int): ConnectionIO[ProfF[Int]] =
            for {
              d  <- tsql"SELECT name, year FROM prof WHERE id = $id".unique[(String, Int)]
              ss <- tsql"SELECT id FROM prof WHERE parent = $id".as[List[Int]]
            } yield ProfF(d._1, d._2, ss)

                // Wow, ProfF[A] had ProfF[Professor] amd ProfF[Int]
                      
             </code></pre>
            </section>



            <section data-transition="fade-out">
              <h3>Read it back </h3>
              <pre><code class=" hljs scala" style="font-size:25px; align-items: center;"  data-trim>
def readNode2(id: Int): ConnectionIO[ProfF[ProfF[Int]]] =
  readNode(id).flatMap(_.traverse(readNode))

 def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  readNode(id).flatMap { pi =>
    pi.traverse(readTree)
      .map(Cofree(id, _))
  }
             </code></pre>
            </section>


            <section data-transition="fade-out">
              <h3>Is that recursion scheme ?</h3>
              <pre><code class=" hljs scala" style="font-size:25px; align-items: left;"  data-trim>
                // I think, not reaaally. But now I am hoping,
                // atleast a few of you are motivated. Now, its time to find the mechanics and make it working.
                1. Catamorphism :: Algebra[F[_], A] => A // We already seen this, bottom up folding of structure
                2. cataM        ::  Algebra[F[_], A] = F[A] => M[A], wher M can be Either[String, *]
                3. Anamorphism  :: top bottom unfold
                4. Paramorphism :: Similar to cata.
                5. Ofcourse, get so used to Free, and Cofree, Mu and many many more possibilites.

             </code></pre>
            </section>
            
      <section data-transition="fade-in">
        <h4>That was 40 free occurrences of word "recursion"</h4>
        <h4> Thanks </h3>
      </section>

      <!-- Slide 20 -->
    </div>
  </div>

  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      // ...

      // The "normal" size of the presentation, aspect ratio will be preserved
      // when the presentation is scaled to fit different resolutions. Can be
      // specified using percentage units.
      width: 1300,
      height: 750,

      // Factor of the display size that should remain empty around the content
      margin: 0.1,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.5,
      history: true,
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true },
        { src: 'https://d3js.org/d3.v4.min.js' },
        { src: 'plugin/d3js/d3js.js' }
      ]
    });
  </script>
</body>

</html>
